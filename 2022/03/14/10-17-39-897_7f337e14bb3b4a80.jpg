<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head profile="http://gmpg.org/xfn/11">

	<title>  Game Angst</title>

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />	
	<meta name="generator" content="WordPress 5.8.4" /> <!-- leave this for stats please -->

	<link rel="stylesheet" href="http://gameangst.com/wp-content/themes/primepress/style.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="http://gameangst.com/wp-content/themes/primepress/custom.css" type="text/css" media="screen" />
	<!--[if lte IE 6]>	<link rel="stylesheet" type="text/css" href="http://gameangst.com/wp-content/themes/primepress/library/ie6.css" /><![endif]-->
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://gameangst.com/?feed=rss2" />
	<link rel="alternate" type="text/xml" title="RSS .92" href="http://gameangst.com/?feed=rss" />
	<link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="http://gameangst.com/?feed=atom" />
	<link rel="pingback" href="http://gameangst.com/xmlrpc.php" />
	
	
	<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='//s.w.org' />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/13.1.0\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/13.1.0\/svg\/","svgExt":".svg","source":{"concatemoji":"http:\/\/gameangst.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=5.8.4"}};
			!function(e,a,t){var n,r,o,i=a.createElement("canvas"),p=i.getContext&&i.getContext("2d");function s(e,t){var a=String.fromCharCode;p.clearRect(0,0,i.width,i.height),p.fillText(a.apply(this,e),0,0);e=i.toDataURL();return p.clearRect(0,0,i.width,i.height),p.fillText(a.apply(this,t),0,0),e===i.toDataURL()}function c(e){var t=a.createElement("script");t.src=e,t.defer=t.type="text/javascript",a.getElementsByTagName("head")[0].appendChild(t)}for(o=Array("flag","emoji"),t.supports={everything:!0,everythingExceptFlag:!0},r=0;r<o.length;r++)t.supports[o[r]]=function(e){if(!p||!p.fillText)return!1;switch(p.textBaseline="top",p.font="600 32px Arial",e){case"flag":return s([127987,65039,8205,9895,65039],[127987,65039,8203,9895,65039])?!1:!s([55356,56826,55356,56819],[55356,56826,8203,55356,56819])&&!s([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]);case"emoji":return!s([10084,65039,8205,55357,56613],[10084,65039,8203,55357,56613])}return!1}(o[r]),t.supports.everything=t.supports.everything&&t.supports[o[r]],"flag"!==o[r]&&(t.supports.everythingExceptFlag=t.supports.everythingExceptFlag&&t.supports[o[r]]);t.supports.everythingExceptFlag=t.supports.everythingExceptFlag&&!t.supports.flag,t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.everything||(n=function(){t.readyCallback()},a.addEventListener?(a.addEventListener("DOMContentLoaded",n,!1),e.addEventListener("load",n,!1)):(e.attachEvent("onload",n),a.attachEvent("onreadystatechange",function(){"complete"===a.readyState&&t.readyCallback()})),(n=t.source||{}).concatemoji?c(n.concatemoji):n.wpemoji&&n.twemoji&&(c(n.twemoji),c(n.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel='stylesheet' id='wp-block-library-css'  href='http://gameangst.com/wp-includes/css/dist/block-library/style.min.css?ver=5.8.4' type='text/css' media='all' />
<link rel="https://api.w.org/" href="http://gameangst.com/index.php?rest_route=/" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://gameangst.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://gameangst.com/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 5.8.4" />
<link rel="stylesheet" href="http://gameangst.com/wp-content/plugins/deans_code_highlighter/geshi.css"  type="text/css" /></head>
<body class="custom">
<div id="page" class="hfeed content-620px">

	<div id="header">
		<div id="branding">
						<h1 class="homelink"><a href="http://gameangst.com" title="Game Angst">Game Angst</a></h1>
						<p class="description">because there are many ways to skin a cat, but you only get to choose one</p>
		</div>
		
		<div id="skip"><a title="Skip to content" href="#primary" accesskey="S">Skip to Content &darr;</a></div>
		
		<ul class="menu">
				<li class="current_page_item"><a title="Game Angst" href="http://gameangst.com">Home</a></li>
	<li class="page_item page-item-2"><a href="http://gameangst.com/?page_id=2">About</a></li>
		</ul>
	</div><!--#header-->
<div id="container">
	<div id="rotating">
		<img src="http://gameangst.com/wp-content/themes/primepress/headers/pp-header.jpg" 
width="920" alt="" title="" />	</div>	
	<div id="primary" class="looped">
		
				
				
		<div id="post-585" class="entry post-585 post type-post status-publish format-standard hentry category-uncategorized tag-despair-engine tag-optimization">
			
			<h2 class="entry-title"><a href="http://gameangst.com/?p=585" rel="bookmark" title="Permalink to Low-Fragmentation, High-Performance Memory Allocation in Despair Engine">Low-Fragmentation, High-Performance Memory Allocation in Despair Engine</a></h2>
			
			<div class="entry-byline">
				<span class="entry-date"><abbr class="updated" title="2012-05-13T23:14:48-0400">May 13th, 2012</abbr></span>
				<address class="author vcard">by <a class="url fn" href="http://">Adrian Stone</a>. </address>
				<a href="http://gameangst.com/?p=585#comments" class="comments-link" >10 comments</a>							</div>
			
			<div class="entry-content">
				<p><a href="http://gameangst.com/?p=496">I recently wrote about dlmalloc</a> and how it is a poor choice for a memory allocator for console games.  As I explained in my previous article, dlmalloc has two major limitations.  It manages a pool of address space composed of discrete regions called <em>segments</em>.  It can easily add segments to grow its pool of address space, but it can&#8217;t easily remove segments to return address space to the OS.  Additionally, it doesn&#8217;t distinguish between physical and virtual memory, which means that it can&#8217;t take advantage of virtual memory&#8217;s ability to combat fragmentation.</p>
<p>During the development of FEAR 3, to address these limitations, I implemented a new general-purpose allocator based on <a href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> called <em>dsmalloc</em>.  <em>Dsmalloc</em> makes two important improvements to dlmalloc.</p>
<p>The first improvement is in how <em>dsmalloc</em> treats segments.  In <em>dsmalloc</em>, segments are always managed as completely distinct regions of memory.  <em>Dsmalloc</em> will never coalesce adjacent segments.  Because of this, <em>dsmalloc</em> tracks segments much more closely than dlmalloc.  By overlaying a second intrusive data structure in the free bits of the boundary tag structure used to track individual allocations, <em>dsmalloc</em> can, in constant time and with no memory overhead, determine with every free operation when a segment is no longer occupied and can be returned to the system.</p>
<p>The second improvement is that <em>dsmalloc</em> recognizes the difference between reserved address space and allocated memory.  Unlike dlmalloc, which uses two callbacks to allocate and free system memory, <em>dsmalloc</em> exposes four callbacks, two to reserve and release segment-sized regions of virtual address space, and two to commit and decommit page-sized subregions of segments.</p>
<p>Just as <em>dsmalloc</em> never leaves any unoccupied segments reserved, it also never leaves any unoccupied pages committed.</p>
<blockquote>
<div class="dean_ch" style="white-space: nowrap;"><span class="kw4">typedef</span> <span class="kw4">void</span>* <span class="br0">&#40;</span>*ReserveSegmentFunc<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">size_t</span> size<span class="br0">&#41;</span>;<br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span>*ReleaseSegmentFunc<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span>* ptr, <span class="kw4">size_t</span> size<span class="br0">&#41;</span>;<br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span>*CommitPageFunc<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span>* ptr, <span class="kw4">size_t</span> size<span class="br0">&#41;</span>;<br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span>*DecommitPageFunc<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span>* ptr, <span class="kw4">size_t</span> size<span class="br0">&#41;</span>;</p>
<p>MemorySpace* CreateMemorySpace<span class="br0">&#40;</span><br />
&nbsp; &nbsp; <span class="kw4">size_t</span> initialCapacity,<br />
&nbsp; &nbsp; ReserveSegmentFunc reserveSegmentFunc,<br />
&nbsp; &nbsp; ReleaseSegmentFunc releaseSegmentFunc,<br />
&nbsp; &nbsp; CommitPageFunc commitPageFunc,<br />
&nbsp; &nbsp; DecommitPageFunc decommitPageFunc,<br />
&nbsp; &nbsp; <span class="kw4">size_t</span> pageSize,<br />
&nbsp; &nbsp; <span class="kw4">size_t</span> segmentGranularity,<br />
&nbsp; &nbsp; <span class="kw4">size_t</span> segmentThreshold <span class="br0">&#41;</span>;</div>
</blockquote>
<p>These two extensions are implemented without any additional memory overhead compared to dlmalloc and with very little computational overhead.  The added cost is a few percent in targeted tests, but in a real-world scenario the performance difference between dlmalloc and <em>dsmalloc</em> isn&#8217;t even measurable.</p>
<p>The great thing about these two changes to dlmalloc is that they enable a wide range of allocation strategies that otherwise wouldn&#8217;t be feasible.</p>
<p>Individual systems within the Despair Engine are free to create separate <em>dsmalloc</em> instances (or <em>regions</em>) for their own use.  Because <em>dsmalloc</em> instances are so aggressive about returning memory to the system, they incur minimal internal fragmentation costs and can coexist gracefully with other system allocators.  Thread-safety is left to the users of <em>dsmalloc</em>, so individual systems can bypass thread synchronization costs entirely or at least use local locks to avoid contention with other allocators.  Using separate <em>dsmalloc</em> instances also provides systems with easier tracking of memory allocations, tighter enforcement of budgets, and, if their allocation patterns exhibit temporal or spatial locality within their own systems, reduced external fragmentation.</p>
<p>For systems that don&#8217;t want to bother with using a custom allocator (which, frankly, most don&#8217;t), Despair Engine provide a common allocator which services request from the tradition global allocation functions like operator new, malloc, and XMemAlloc.  This common allocator also utilizes <em>dsmalloc</em> instances under the hood.</p>
<p>The common allocator creates one <em>dsmalloc</em> instance for allocations larger than 256 bytes and 20 <em>dsmalloc</em> instances covering allocations at every 8 byte size interval less than 64 bytes and every 16 byte interval between 64 and 256 bytes.  The instance for large allocations uses a 32 megabyte segment size and 64 kilobyte pages whereas the small allocation instances use 64 kilobyte segments.  Using page-sized segments for the small allocation regions is a minor optimization that removes the need for <em>dsmalloc</em> to track address reservation and memory commission separately for these regions.</p>
<p>Bucketing small allocations into so many discrete regions significantly reduces external fragmentation in our games, despite creating a modest increase in internal fragmentation.  Since only allocations within a single region need to be synchronized, it also has a side benefit of greatly reducing contention between allocations from multiple threads.</p>
<p>It is worth noting that since the various small allocation regions are essentially used for fixed-size allocations, they could be more efficiently implemented as dedicated fixed-block allocators.  We have such an implementation in the engine, but <em>dsmalloc</em> (like dlmalloc) already implements an internal small, fixed-block allocation optimization, so in practice it is more convenient to use <em>dsmalloc</em> instances for everything and almost as efficient.</p>
<p>One key benefit of using <em>dsmalloc</em> instances for small allocations instead of a pure fixed-block allocator is that it offers us more flexibility in how the small allocation regions are configured.  At the time I was implementing this in FEAR 3, minimizing fragmentation was our top concern, but in the future we might choose to prioritize thread synchronization efficiency over memory consumption.  Instead of routing allocations to regions based on their size, we could create just a few small allocation regions and cycle between them based on thread contention.  The idea is to allow a thread to try to lock a region for allocation, but rather than waiting if the region is already in use by another thread, simply move on to another region and try again.</p>
<p><em>Dsmalloc</em> is flexible enough to support both of these strategies efficiently or, in fact, any hybrid combination of the two.</p>
<p>The <em>dsmalloc</em> callbacks are designed to be easily mappable to OS functions such as <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx">VirtualAlloc</a> in Windows, but sometimes these functions are too expensive to be used directly.  To improve performance, on some platforms the Despair general allocator utilizes a commit cache.  The commit cache is a simple <a href="http://dictionary.reference.com/browse/direct+mapped+cache">direct-mapped cache</a> that sits between the <em>dsmalloc</em> commit callback and the OS.  <em>Dsmalloc</em> already optimizes allocation order to maximize cache efficiency, and this benefits the commit cache as well.  A 32 megabyte commit cache is probably overly generous, but it guarantees that OS-level calls don&#8217;t show up in our profiles even during content streaming transitions.</p>
<p>Having the cache implemented external to <em>dsmalloc</em> is also useful.  When memory is extremely tight, anything that doesn&#8217;t utilize the general allocator could fail even though memory is still available in the commit cache.  In those extreme cases the commit cache can be manually prompted to return pages to the system ensuring that OS-level allocations never fail because the memory they need is held in a cache.</p>
<p>There is one additional complication that plagues the consoles.  On both the Xbox 360 and the Playstation 3, the GPU does not share the CPU&#8217;s memory mapping unit.  On the Xbox 360 the GPU requires physically contiguous memory for all resources and on the PS3 the GPU has a separate MMU with only 1 megabyte page granularity.  Since we use <em>dsmalloc</em> with 64 kilobyte pages to minimize fragmentation, this means we&#8217;re susceptible to physical memory fragmentation when it comes to resources allocated for the GPU.  On the Xbox 360, unbeknownst to many developers, the OS copes with this automatically.  When a physical allocation request can&#8217;t be satisfied due to physical memory fragmentation, the Xbox 360 operating system locks the entire address space and defragments physical memory pages (by memcpy&#8217;ing physical pages and remapping virtual addresses) to accommodate the request.</p>
<p>On the PS3 the OS doesn&#8217;t provide this service automatically, but the same basic need exists.  64 kilobyte pages must be locked and relocated to generate contiguous 1 megabyte pages appropriate for the GPU.  Thankfully with a little bit of acrobatics it is possible to do just that without violating certification requirements.</p>
<p>Although the operation is every bit as expensive as it sounds, it proved necessary to keep FEAR 3 from crashing.  FEAR 3 ran dangerously close to the limits of memory on the Playstation 3 and survived only by allowing flexible budgets for every kind of memory.  GPU allocations in main memory varied by over 100% between streaming regions so not only did CPU addressable memory need to be defragmented for use by the GPU, GPU addressable memory had to be defragmented continually and returned to the CPU.  The really expensive CPU defragmentation provided a safety net against crashes at all times, but thankfully it was only needed at major chapter transitions where a load screen was expected and a 100 ms hitch was infinitely preferable to an out and out crash.</p>
<p>When I undertook to rewrite the Despair memory allocator near the end of FEAR 3, the overarching goal was to never fail to satisfy an allocation request due to prior memory usage patterns.  If a level fit just barely into memory after a fresh boot, we wanted it to fit equally well in memory after a hundred hours of continuous play.  While I can&#8217;t pretend that fragmentation doesn&#8217;t exist at all in the system I devised, I can say that it was so dramatically reduced that we were able to establish an upper bound on fragmentation and enforce budgets for our content that were reliable regardless of the order or duration in which the game was played.</p>
<p>The new Despair memory allocator based on <em>dsmalloc</em> ran the same content as the old memory allocator on all platforms with a slightly lower lower bound on memory, a much lower upper bound on memory, and it even managed a slightly lower run-time performance cost.</p>
							</div>
			
			<p class="entry-meta"><!-- <span class="entry-categories">Posted in: <a href="http://gameangst.com/?cat=1" rel="category">Uncategorized</a>.</span><br /> -->
							<span class="entry-tags">Tagged: <a href="http://gameangst.com/?tag=despair-engine" rel="tag">Despair Engine</a> &middot; <a href="http://gameangst.com/?tag=optimization" rel="tag">optimization</a><br /></span>
			</p>
		</div><!--.entry-->
		
				
		<div id="post-526" class="entry post-526 post type-post status-publish format-standard hentry category-uncategorized tag-concurrency tag-despair-engine tag-f-e-a-r-3 tag-fracture tag-optimization">
			
			<h2 class="entry-title"><a href="http://gameangst.com/?p=526" rel="bookmark" title="Permalink to Scalable Concurrency in Despair Engine">Scalable Concurrency in Despair Engine</a></h2>
			
			<div class="entry-byline">
				<span class="entry-date"><abbr class="updated" title="2012-04-05T17:07:57-0400">Apr 5th, 2012</abbr></span>
				<address class="author vcard">by <a class="url fn" href="http://">Adrian Stone</a>. </address>
				<a href="http://gameangst.com/?p=526#comments" class="comments-link" >6 comments</a>							</div>
			
			<div class="entry-content">
				<p>In my last article I promised a follow-up description of the memory allocation system that I wrote for <a href="http://www.day1studios.com/company/despair-engine/" target="_blank">Despair Engine</a> during the development of F.E.A.R. 3.  Before I get to that, however, I&#8217;ve been inspired by <a href="http://cbloomrants.blogspot.com/">Charles Bloom</a>&#8216;s recent posts on the <a href="http://cbloomrants.blogspot.com/2011/12/12-03-11-worker-thread-system-with.html">job queue system</a> that is apparently part of <a href="http://www.radgametools.com/">RAD Game Tools</a>&#8216; Oodle, and I thought it might be interesting to describe the current job system and thread layout in Despair.</p>
<p>The &#8220;concurrency manager&#8221; in Despair Engine consists of worker threads and job queues.  By default there is one pool of worker threads that share a single job queue, referred to as public workers, and some number of additional worker threads, each with its own job queue, referred to as private workers.</p>
<p>The job queues and their worker threads are relatively simple constructs.  Jobs can be added to a queue from any thread and, when jobs are added, they create <a href="http://en.wikipedia.org/wiki/Futures_and_promises" target="_blank">futures</a> which can be used to wait on the job&#8217;s completion.  A job queue doesn&#8217;t directly support any concept of dependencies between jobs or affinities to limit which worker threads a job can run on.</p>
<p>Jobs are fetched by worker threads in strictly FIFO order, but with multiple worker threads servicing a single queue, that doesn&#8217;t provide many guarantees on the order in which jobs are processed.  For example, jobs <em><strong>A</strong></em> and <em><strong>B</strong></em>, enqueued in that order, may be fetched consecutively by worker threads <strong>1</strong> and <strong>2</strong>.  Because these tasks are asynchronous, worker thread <strong>2</strong> might actually manage to start and finish processing job <em><strong>B</strong></em> before worker thread <strong>1</strong> has done any meaningful work on job <em><strong>A</strong></em>.</p>
<p>What this means in practice is that any job added to the public worker queue must be able to be processed on any public worker thread and concurrently with any other job in the queue.  If a job really needs to enforce a dependency with other jobs, it can do so by either waiting on the futures of the jobs it is dependent on or by creating the jobs that are dependent on it at the end of its execution.  Combinations of these techniques can be used to create almost arbitrarily complex job behavior, but such job interactions inhibit maximum parallelism so we try to avoid them in our engine.</p>
<p>Public worker threads are mostly used by <a href="http://en.wikipedia.org/wiki/Data_parallelism" target="_blank">data-parallel</a> systems that divide their work into some multiple of the number of public workers, enqueue jobs for each worker, and then, at some later point in the frame, wait on all the jobs&#8217; futures.  Examples of systems like this are animation, cloth simulation, physics, effects, and rendering.  Although all of the users of the public job queue try to provide as much time as possible between adding work to the queue and blocking on its completion, work in the public job queue is considered high-priority and latency intolerant.</p>
<p>Systems that have work that can be processed asynchronously, but doesn&#8217;t meet the requirements of the public job queue, create private job queues.  The primary reason for using a private job queue is that the work is long but latency tolerant, and we don&#8217;t want it delaying the latency intolerant work in the public job queue.</p>
<p>In Fracture, terrain deformation was processed in a private worker thread, consuming as much as 15 ms a frame but at low priority.</p>
<div style="width: 430px" class="wp-caption aligncenter"><iframe loading="lazy" width="500" height="375" src="http://www.youtube.com/embed/m_o2BFvhqt4?feature=oembed" frameborder="0" allowfullscreen></iframe><p class="wp-caption-text">Terrain deformation in Fracture</p></div>
<p>Starting with F.E.A.R. 3, decals have used a private worker thread.  The decal thread generates and clips geometry from a queue.  Although the queue might hold several hundred milliseconds of work, it will happily take only what time slices it can get from a single thread until it finishes its backlog.</p>
<p>We also use private worker threads for systems that have restrictions on their degree of parallelism or that perform primarily blocking work.  Save data serialization, background resource loading, audio processing, network transport, and, on the PC, communication with the primary Direct3D context fall into this category.</p>
<p>I&#8217;ve had occasion over the years to use the Despair concurrency manager for a wide variety of tasks with a wide range of requirements, and I have very few complaints.  I find the system simple and intuitive, and it is usually immediately obvious, given a new task, whether a private or public job queue is appropriate.  I&#8217;ve occasionally wished for a richer set of scheduling options within the job queues themselves, but I ultimately believe that complex scheduling requirements are a symptom of bad multithreaded design and that if complex scheduling truly is justified, it is better handled within the jobs themselves.</p>
<p>The one area where scheduling has given me a lot of trouble, however, and where I wish we could offer some improvement, is in the interaction of public and private worker threads. When the platform, code, and content are reasonably stable, it isn&#8217;t too difficult to arrange the public and private workers such that they share the available processor resources efficiently.</p>
<p>On the Xbox 360, for example, where there are 6 hardware threads available, we have the main thread with affinity to hardware thread 0, four public worker threads with separate affinity to hardware threads 1, 2, 3, and 5, and most of our private worker threads sharing affinity with hardware thread 4.  This arrangement ensures that the main thread and the public workers are never interrupted by the private worker threads, and it means that the private workers get a roughly equal share of an entire hardware thread.  We know exactly how fast the hardware is and we can predict with a high degree of accuracy how much work each private worker will receive, so we don&#8217;t need to worry about oversubscription or underutilization of hardware thread 4.</p>
<p>In cases where the private worker threads aren&#8217;t sharing the load in a way we consider optimal, we can tweak either the hardware thread affinity or the software thread priorities to get the behavior we want.  For example, in F.E.A.R. 3 we offloaded some marshaling of data for network transport to a private worker thread.  Jobs for that thread were generated near the end of each frame and they had to be completed near the beginning of the following frame.  If the private workers were left to the OS scheduler, the decal thread might preempt the network thread during that crucial window and cause a stall in the next frame.  Since we knew the network thread never generated more than 5-6 ms of single-threaded work, we could safely boost its thread priority and ensure that it was never preempted by decals.</p>
<p>In another case where we weren&#8217;t 100% satisfied with the default scheduling of a private worker, we moved the private worker to share a hardware thread with one of the public workers but also lowered its thread priority.  The luxury of a fixed, single-process platform is that we can hand tune the thread layout and be confident that our results will match those of our customers.</p>
<div id="attachment_568" style="width: 810px" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-568" loading="lazy" class="size-large wp-image-568 " title="Xbox 360 PIX Capture" src="http://gameangst.com/wp-content/uploads/2012/03/XboxPIXCapture3-800x160.png" alt="" width="800" height="160" srcset="http://gameangst.com/wp-content/uploads/2012/03/XboxPIXCapture3-800x160.png 800w, http://gameangst.com/wp-content/uploads/2012/03/XboxPIXCapture3-150x30.png 150w, http://gameangst.com/wp-content/uploads/2012/03/XboxPIXCapture3-400x80.png 400w, http://gameangst.com/wp-content/uploads/2012/03/XboxPIXCapture3.png 1409w" sizes="(max-width: 800px) 100vw, 800px" /><p id="caption-attachment-568" class="wp-caption-text">Example hardware thread utilization in F.E.A.R. 3, as captured by PIX on the Xbox 360</p></div>
<p>In the capture above you can see examples of both the situations I described.  The thin colored lines represent software threads and the thick blocks above them represent individual jobs.  A high priority audio thread, shown in yellow, interrupts a job on hardware thread 4, but that&#8217;s okay because the job being interrupted is latency tolerant.  Later in the frame another thread, shown in light blue, schedules nicely with the latency intolerant jobs in the pink public worker on hardware thread 5.</p>
<p>The PC is where things get messy.  On the PC we worry most about two different configurations.  One is the low end, which for us is a dual core CPU, and the other is the high end, which is a hyper-threaded quad core CPU.</p>
<p>Currently, on the PC we allocate MAX(1, num_logical_processors-2) public worker threads.  On a hyper-threaded quad core that means 6 public worker threads and on a dual core that means just 1 public worker thread.  Unlike on the Xbox 360, however, we don&#8217;t specify explicit processor affinities for our threads, nor do we adjust thread priorities (except for obvious cases like an audio mixer thread).  We don&#8217;t know what other processes might be running concurrently with our game and, with variations in drivers and platform configurations, we don&#8217;t even know what other third-party threads might be running in our process.  Constraining the Windows scheduler with affinities and thread priorities will likely lead to poor processor utilization or even thread starvation.</p>
<p>That&#8217;s the convention wisdom anyway, but it sure doesn&#8217;t look pretty in profiles.  From a bird&#8217;s eye view the job system appears to work as expected on the PC.  As the number of cores increase, the game gets faster.  Success!  If it weren&#8217;t for our internal thread profiler and the <a href="http://msdn.microsoft.com/en-us/magazine/ee336027.aspx">Concurrency Visualizer</a> in Visual Studio 2010 we&#8217;d probably have been happy with that and moved on.</p>
<p>On high-end PCs things aren&#8217;t too bad.  Both our job queue visualization and Visual Studio&#8217;s thread visualization sometimes show disappointing utilization of our public workers, but that&#8217;s not necessarily a problem.  We know we&#8217;re oversubscribed because we have more software threads created by the engine than there are hardware threads and there are at least 3 other third-party threads in our process doing meaningful work not to mention the other processes in the system.  One of the benefits of a thread pool is that the number of participating threads can scale with the environment.  Thankfully the behavior we usually see in these cases is fewer public workers tackling more jobs rather than all public workers starting jobs and then some being preempted, which would block the job queue until they can be rescheduled.</p>
<div id="attachment_577" style="width: 587px" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-577" loading="lazy" class="size-full wp-image-577 " title="Dual Core Preemption" src="http://gameangst.com/wp-content/uploads/2012/03/DualCorePreemption.png" alt="" width="577" height="150" srcset="http://gameangst.com/wp-content/uploads/2012/03/DualCorePreemption.png 577w, http://gameangst.com/wp-content/uploads/2012/03/DualCorePreemption-150x38.png 150w, http://gameangst.com/wp-content/uploads/2012/03/DualCorePreemption-400x103.png 400w" sizes="(max-width: 577px) 100vw, 577px" /><p id="caption-attachment-577" class="wp-caption-text">Job visualization from the same portion of two adjacent frames on a dual core PC</p></div>
<p>The image above is an example from our internal thread profiler.  I had to zoom and crop it a bit to fit on the page, but what you&#8217;re seeing is the same portion of two frames on a dual core machine.  The colored blocks represent jobs.  You can see in the first frame a long stretch in which the main thread is processing jobs while the single worker thread is sitting idle.  The next frame shows the intended behavior, with both the main thread and the worker thread processing jobs equally.  We can&#8217;t visualize third-party threads or other processes with our internal profiler, so we have to turn to Visual Studio&#8217;s profiler to see what&#8217;s preempting our worker in that first frame.  In our case it is usually the video driver or audio processor, but really any thread could be at fault.  The more active threads in the system, including our own private workers, the more likely this sort of interference becomes.</p>
<p>The other behavior that is a little disappointing on many-core PCs is the high percentage of cross-core context switches.  The Windows scheduler prioritizes quite a few factors above keeping a thread on its current core, so it isn&#8217;t too big a surprise for threads to jump cores in an oversubscribed system.  The cost is some nebulous decrease in CPU cache coherency that is all but impossible to measure.  Short of setting explicit processor affinities for our threads, which hurts overall performance, I haven&#8217;t had any luck improving this behavior.  I had hoped to combat this effect with <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686253(v=vs.85).aspx">SetThreadIdealProcessor</a>, but I haven&#8217;t actually been able to detect any change in scheduling when calling this function so we don&#8217;t use it.</p>
<p>On a high-end PC, as <a href="http://youtu.be/8r1CZTLk-Gk" target="_blank">Louis C.K.</a> might say, these are <a href="http://first-world-problems.com/" target="_blank">first world problems</a>.  With 8 logical processors we can afford to be less than perfect.  From my profiles, even the best PC games are barely utilizing 30% of an 8 processor PC, and we&#8217;re comfortably within that range so I&#8217;m not complaining.</p>
<p>On dual core machines these issues can&#8217;t be ignored.  With only two hardware threads, we&#8217;re now massively oversubscribed.  The particularly difficult situation that we have to cope with is when all of our private workers are fully occupied at the same time. As I explained earlier, the decal thread is latency tolerant, but it can buffer far more than a single frame&#8217;s worth of work.  This means that, left unchallenged, it alone can consume a full core for a full frame.  Video drivers usually have their own threads which might, under heavy load, consume 25% of a core, audio might want another 20%, and Steam another 20%.  All told we can have two thirds of a core&#8217;s worth of work in miscellaneous secondary threads and another full cores&#8217;s worth of work in the decal thread.  That&#8217;s 1.7 cores worth of work competing on a level playing field with the main job queue on a machine with only 2 cores!</p>
<p>For most of these threads we have a general optimization problem more than a concurrency problem.  We don&#8217;t have much flexibility in when or how they run, we just need to lower their cost.  The decal thread, on the other hand, is different.  Its purpose is to periodically consume far more work than would normally be budgeted for a single frame and to amortize the cost of that work over multiple frames.  If it is impacting the execution of other threads then it isn&#8217;t doing its job.</p>
<p>My first reaction to this problem was, as usual, to wish for a more sophisticated scheduler in the public job queue.  It seemed as though an easy solution would be to stick decal jobs in the public job queue and to instruct the scheduler to budget some fraction of every second to decal processing while trying to schedule decal jobs only at times when no other jobs are pending.  After some consideration, however, I realized that this was asking too much of the scheduler and, perversely, would still require a lot of work in the decal system itself.  Since the job scheduler isn&#8217;t preemptive, even a powerful system of budgets and priorities would rely on the jobs themselves being of sufficiently small granularity.  The decal system would have to break up large jobs to assist the scheduler or, similarly, implement a cooperative yielding strategy that returned control to the scheduler mid-execution.</p>
<p>In addition to assisting the scheduler, the decal system would also have to become aware of how its rate of production was being throttled.  Since decal resources are recycled using a heuristic that is heavily LRU, the decal system must manage the rate of input requests to match the rate of production in order to ensure that decals aren&#8217;t being recycled as soon as they are created.</p>
<p>It seems that any additional complexity added to the job scheduler is going to require equal complexity to be added to the decal system in order to take advantage of it.  That&#8217;s always a red flag for me in systems design.</p>
<p>I&#8217;m still weighing some options for dealing with the decal thread, but my current favorite is to swallow my fears and seek help from the OS thread scheduler.  If we reduce the thread priority of the decal thread under Windows, it will only be given time when the cores would otherwise be idle.  However, since Windows implements <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684828(v=vs.85).aspx">thread boosts</a>, even in a completely saturated environment the decal thread won&#8217;t starve completely.  Nevertheless, this is a risky strategy because it creates the ability for the decal thread to block other threads through <a href="http://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>.  This probably isn&#8217;t a scalable long-term solution, but given our current thread layout and hardware targets, it achieves the desired result.</p>
<p>The difficulty of achieving maximum throughput on multicore processors is something that is often talked about in games, but what is less often talked about is how much harder this is on the PC than on the consoles.  Maximizing throughout on high-end PCs is great, but, as I&#8217;ve shown, it must be done without sacrificing response time on low-end PCs.  With our current approach I&#8217;ve been pretty pleased with our progress in this area, but I&#8217;m nevertheless having a hard time envisioning a day when we can fully utilize the resources of an 8 processor machine and still continue to provide a compatible play experience on a lowly dual core.</p>
<p>Hopefully by that time we&#8217;ll have broad support for GPGPU tasks as well as the scheduling flexibility to rely on them for more of our latency tolerant work.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
							</div>
			
			<p class="entry-meta"><!-- <span class="entry-categories">Posted in: <a href="http://gameangst.com/?cat=1" rel="category">Uncategorized</a>.</span><br /> -->
							<span class="entry-tags">Tagged: <a href="http://gameangst.com/?tag=concurrency" rel="tag">concurrency</a> &middot; <a href="http://gameangst.com/?tag=despair-engine" rel="tag">Despair Engine</a> &middot; <a href="http://gameangst.com/?tag=f-e-a-r-3" rel="tag">F.E.A.R. 3</a> &middot; <a href="http://gameangst.com/?tag=fracture" rel="tag">Fracture</a> &middot; <a href="http://gameangst.com/?tag=optimization" rel="tag">optimization</a><br /></span>
			</p>
		</div><!--.entry-->
		
				
		<div id="post-496" class="entry post-496 post type-post status-publish format-standard hentry category-uncategorized tag-despair-engine tag-optimization">
			
			<h2 class="entry-title"><a href="http://gameangst.com/?p=496" rel="bookmark" title="Permalink to The Hole That dlmalloc Can&#8217;t Fill">The Hole That dlmalloc Can&#8217;t Fill</a></h2>
			
			<div class="entry-byline">
				<span class="entry-date"><abbr class="updated" title="2012-03-02T14:53:59-0500">Mar 2nd, 2012</abbr></span>
				<address class="author vcard">by <a class="url fn" href="http://">Adrian Stone</a>. </address>
				<a href="http://gameangst.com/?p=496#comments" class="comments-link" >9 comments</a>							</div>
			
			<div class="entry-content">
				<h2><strong>dlmalloc</strong></h2>
<p><a href="http://g.oswego.edu/dl/html/malloc.html">Dlmalloc</a> is a general-purpose memory allocator developed by <a href="http://g.oswego.edu/">Doug Lea</a> since 1987.  It is highly optimized, easily portable, and elegantly designed.  It functions as a drop-in replacement for malloc and the source has been generously released into the public domain.  The code is also an absolute joy to read, with every line conveying volumes of careful intention—optimizations, bug fixes, and refinements thoughtfully integrated over the years.  With so many positive attributes to recommend it, it is no wonder dlmalloc has become the gold standard for memory allocators and a popular choice for game developers.  It is also really unfortunate, because <strong>dlmalloc is a terrible allocator for today’s game consoles</strong>.</p>
<p>To understand why this is, you must first have an overview of dlmalloc’s interface and how it works.  Dlmalloc manages a pool of address space composed of one or more discrete regions called <em>segments</em>.  Dlmalloc’s pool can optionally grow or shrink through user-provided callbacks to allocate new segments and free unused ones.  The “grow” callback is triggered when dlmalloc can’t satisfy an allocation request within its currently managed pool of memory and the “shrink” callback is triggered when dlmalloc detects that a segment is no longer occupied by any allocations.  The grow callback is typically implemented with OS-level functions that allocate memory such as <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx">VirtualAlloc</a>, <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html">mmap</a>, or <a href="http://linux.die.net/man/2/sbrk">sbrk</a>.</p>
<p>Dlmalloc is a <a href="http://www.amazon.com/Art-Computer-Programming-Fundamental-Algorithms/dp/0201896834" target="_blank">boundary tag allocator</a> at its heart, so segments are treated like new nodes in an intrusive linked list and are written with small headers or footers.  The important thing to note about this is that dlmalloc requires that all memory it manages be readable and writable.  The grow callback can return virtual memory, but it must already be committed (mapped to physical memory) in order for dlmalloc to function.</p>
<p>Another important characteristic of dlmalloc is that while it can return segments through the use of the shrink callback, it is not very aggressive in doing so.  Segments are stored in a linked list and the only way for dlmalloc to coalesce adjacent segments or find empty segments is to perform a linear traversal of that list.  For some users segments may be very large in size and very small in number so the linear traversal is cheap, but for most users segment management isn’t worth the cost, and dlmalloc’s default configuration is to only consider the most recently allocated segment when looking for segments to merge or release.</p>
<p>This is significant because it means dlmalloc&#8217;s callbacks can&#8217;t be used to allocate and commit individual pages of virtual memory.  Trying to use dlmalloc with a segment equivalent to a virtual memory page would be prohibitively expensive or pointless depending on the configuration.</p>
<p>So to summarize, <strong>dlmalloc has no support for virtual memory</strong>.</p>
<p>This may seem like a crippling limitation for such a popular allocator, but in practice it affects very few systems.  In fact, if a system meets any of the following requirements, dlmalloc’s blind spot when it comes to virtual memory is almost completely irrelevant.</p>
<h4>Demand Paging</h4>
<p>Almost all general-purpose computers these days have an operating system that features <a href="http://en.wikipedia.org/wiki/Demand_paging">demand paging</a>.  With demand paging, the operating system keeps track of which pages of virtual memory are needed by the system and tries to keep only those pages resident in memory.  In other words, dlmalloc doesn’t have to bother with the difficult work of committing and decommitting pages because the OS is already doing a pretty good job of it.</p>
<h4>More Physical Memory than Virtual Address Space</h4>
<p>In the consumer space, most applications are 32-bit and run on machines with more than 2 gigabytes of memory.  This includes the most recent big-budget PC games like <a href="http://www.ea.com/crysis-2/blog/pc-specs">Crysis</a>, <a href="http://bf3blog.com/battlefield-3-system-requirements/">Battlefield</a>, <a href="http://www.modernwarfare3forum.com/topic/13452-modern-warfare-3-pc-system-requirements/">Call of Duty</a>, and <a href="http://community.batmanarkhamcity.com/news/latest/item/202-pc-recommended-specs#">Batman</a> since they all have minimum system requirements of at least 2 gigabytes of main memory.  If dlmalloc can commit all of the available address space without penalty, it has no reason not to do it.</p>
<h4>No Virtual Memory or Predictable Allocation Pattern</h4>
<p>Embedded systems are likely to have no virtual memory or to have very predictable allocation patterns that don’t benefit from virtual memory.  The fact that dlmalloc sacrifices virtual memory support and dynamic segment management in favor of speed and simplicity is actually a perk for embedded systems.</p>
<h2>Which Brings Us to Modern Consoles</h2>
<p>Modern game consoles are unusual in that they don’t match any of the above criteria.  Both the <a href="http://en.wikipedia.org/wiki/Xbox_360">Xbox 360</a> and the <a href="http://en.wikipedia.org/wiki/PlayStation_3">Playstation 3</a> have rich support for virtual memory, but the operating systems on the two consoles offer limited or no support for demand paging.  The Xbox 360 has 512 megabytes of physical memory to back its virtual address space and the Playstation 3 has 256 megabytes.  Both consoles provide games with significantly more virtual address space than physical memory, so there is a huge potential upside to managing them separately.</p>
<h2>Why We Care About Virtual Memory</h2>
<p>In the absence of demand paging, <a href="http://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a> exists for one purpose only—to reduce the cost of fragmentation. Fragmentation occurs in any allocator that manages variable-sized blocks of memory which can be freed in arbitrary order.  Consider the diagrams below.  The green blocks are allocations in a system with 10 megabytes of memory.  In the first diagram, most of the available memory has been allocated in variable-sized amounts.  In the second diagram, some of those allocations have been freed.  There are more than 4 megabytes of memory available in diagram 2, but even a 2 megabyte allocation will fail because there are no contiguous blocks of memory large enough to place it.  This phenomenon is known as <a href="http://en.wikipedia.org/wiki/Fragmentation_(computing)#Memory_fragmentation">fragmentation</a>.</p>
<p><img loading="lazy" class="alignnone size-full wp-image-506" title="Physical Memory Fragmentation" src="http://gameangst.com/wp-content/uploads/2012/03/fragmentation1.png" alt="" width="671" height="178" srcset="http://gameangst.com/wp-content/uploads/2012/03/fragmentation1.png 671w, http://gameangst.com/wp-content/uploads/2012/03/fragmentation1-150x39.png 150w, http://gameangst.com/wp-content/uploads/2012/03/fragmentation1-400x106.png 400w" sizes="(max-width: 671px) 100vw, 671px" /></p>
<p>Fragmentation can be a huge problem with any general-purpose allocator.  The less predictable an application’s allocation patterns and the larger the range of its allocation sizes, the more susceptible it is to allocation failure due to fragmentation.  Most console games are large, complex systems integrating code from multiple sources and trying to satisfy a wide range of allocation patterns.  At the same time, the game industry is very competitive, so console games are expected to take maximum advantage of the console hardware’s capabilities.  You simply can’t do that without tackling the problem of memory fragmentation.</p>
<p>The most surefire way to avoid memory fragmentation is to only manage memory in fixed-size blocks.  If every allocation is the same size, any hole left by one allocation can be filled perfectly by another.  Unfortunately requiring that all memory requests be the same size is unreasonable, and trying to do so naively will only result in even more memory waste.  This is where virtual memory comes in.</p>
<p>Virtual memory subdivides all physical memory into fixed-size blocks, known as <em>pages</em>, and provides a mechanism for contiguous allocations of virtual memory to span multiple nonadjacent pages.  By adding this level of indirection, an application can be given an address the behaves like a block of contiguous memory, but under the hood is made up of separate fixed-size allocations of physical memory.  This completely removes the problem of physical memory fragmentation, though it obviously creates the problem of virtual memory fragmentation.  If virtual memory is limited to the same size as physical memory, you’re no better off than when you started.  However, if virtual memory is allowed to be much larger than physical memory, even though fragmentation still exists, it is much less likely to ever cause an allocation failure.</p>
<p>The reason why virtual memory can be larger than physical memory is that unused pages of virtual memory don’t have to be backed by physical memory.  As the name implies, it is <em>virtual</em> resource.</p>
<p>The next set of diagrams shows the exact same sequence of memory allocations as the earlier diagrams, but this time using a slightly larger pool of virtual memory.  Allocations in virtual memory are still marked in green and free regions are still marked in white, but now the diagram is divided into 1 megabyte pages and any pages which are backed by physical memory are shaded with diagonal lines.  In order for an allocation to succeed, it must fit into a free region of virtual memory that is backed by physical pages, ie. white areas shaded with diagonal lines.</p>
<p>In diagram 3 all 10 megabytes of physical memory are allocated, but there are still more than two megabytes of virtual memory available.  A new 2 megabyte allocation could fit in virtual memory, but it will still fail because it can&#8217;t be backed by physical memory.  In diagram 4 some allocations have been freed, and not only is there still 2 megabytes of contiguous virtual memory available, there are two free 1 megabyte physical memory pages available to back it.  Diagram 5 shows the successful addition of a new 2 megabyte allocation, the same allocation that would have failed without virtual memory in diagram 2.  If you count the number of physical pages that are allocated in diagram 5, you’ll see that we haven’t exceeded the system limit of 10 megabytes.</p>
<p><img loading="lazy" class="alignnone size-full wp-image-507" title="Virtual Memory Fragmentation" src="http://gameangst.com/wp-content/uploads/2012/03/fragmentation2.png" alt="" width="798" height="267" srcset="http://gameangst.com/wp-content/uploads/2012/03/fragmentation2.png 798w, http://gameangst.com/wp-content/uploads/2012/03/fragmentation2-150x50.png 150w, http://gameangst.com/wp-content/uploads/2012/03/fragmentation2-400x133.png 400w" sizes="(max-width: 798px) 100vw, 798px" /></p>
<p>Notice that while we’ve succeeded in allocating an additional 2 megabytes despite fragmentation, we still have more than 2 megabytes of virtual memory left and yet we can’t service another 2 megabyte request.  Virtual memory itself is now too fragmented.  We could increase the amount of virtual memory without penalty to make room for another 2 megabyte allocation, but it doesn’t help because although we have 2 megabytes of physical memory that isn’t being used, we don’t have 2 free physical memory pages to back the new allocation.</p>
<p>For virtual memory to be an effective solution to fragmentation, you need a lot more virtual address space than physical memory and you need as small a page size as possible.  On the Xbox 360 the default page size is 64 kilobytes and the on the Playstation 3 it is 1 megabyte, but both consoles support a range of page sizes.  The best page size on consoles for compromising between performance and fragmentation is 64 KB, which begs the question, “why does the Playstation 3 default to 1 megabyte?”  The answer is simple: the Playstation 3 uses dlmalloc for its general-purpose allocator and since dlmalloc doesn’t take advantage of virtual memory, there is no point in using a smaller page size!</p>
<p>Hopefully by now I&#8217;ve convinced you of the value of virtual memory and why dlmalloc isn&#8217;t the right choice for console games.  In the future I&#8217;ll describe the general-purpose memory allocator I wrote for <a href="http://gameangst.com/?tag=despair-engine">Despair Engine</a> and how I used it to combat fragmentation.  As a bonus, I&#8217;ll explain the larger memory management framework that I built on top of the allocator to reduce thread contention and to ensure that the entirety of memory is available to a heterogeneous set of processors, despite their non-unified views of virtual memory.</p>
<p>&nbsp;</p>
							</div>
			
			<p class="entry-meta"><!-- <span class="entry-categories">Posted in: <a href="http://gameangst.com/?cat=1" rel="category">Uncategorized</a>.</span><br /> -->
							<span class="entry-tags">Tagged: <a href="http://gameangst.com/?tag=despair-engine" rel="tag">Despair Engine</a> &middot; <a href="http://gameangst.com/?tag=optimization" rel="tag">optimization</a><br /></span>
			</p>
		</div><!--.entry-->
		
				
		<div id="post-441" class="entry post-441 post type-post status-publish format-standard hentry category-uncategorized tag-crossstitch tag-despair-engine tag-fracture tag-rendering">
			
			<h2 class="entry-title"><a href="http://gameangst.com/?p=441" rel="bookmark" title="Permalink to CrossStitch 2.0: Dynamic Shader Linking in a Statically Linked World">CrossStitch 2.0: Dynamic Shader Linking in a Statically Linked World</a></h2>
			
			<div class="entry-byline">
				<span class="entry-date"><abbr class="updated" title="2010-05-10T18:40:30-0400">May 10th, 2010</abbr></span>
				<address class="author vcard">by <a class="url fn" href="http://">Adrian Stone</a>. </address>
				<a href="http://gameangst.com/?p=441#comments" class="comments-link" >13 comments</a>							</div>
			
			<div class="entry-content">
				<p>In my <a href="http://gameangst.com/?p=402">last article</a>, I described the first generation of <em>CrossStitch</em>, the shader assembly system used in <em><a href="http://xbox.ign.com/objects/655/655496.html">MechAssault 2</a></em>.  Today I&#8217;m going to write about the second generation of <em>CrossStitch</em>, the one used in <em><a href="http://www.lucasarts.com/games/fracture/" target="_blank">Fracture</a></em>.</p>
<p>Development on <em>CrossStitch 2.0</em> began with the development of Day 1&#8217;s <em>Despair Engine</em>.  This was right at the end of <em>MechAssault 2</em>, when the Xbox 360 was still an Apple G5 and the Cell processor was going to be powering everything from super computers to kitchen appliances in a few years.  It is hard to believe looking back, but at that time we were still debating whether to adopt a high-level shading language for graphics.  There were respected voices on the platform side insisting that the performance advantage of writing shaders in assembly language would justify the additional effort.  Thankfully I sided with the HLSL proponents, but that left me with the difficult decision of what to do about <em>CrossStitch</em>.</p>
<p><em>CrossStitch</em> was a relatively simple system targeting a single, very constrained platform.  HLSL introduced multiple target profiles, generic shader outputs, and literal constants, not to mention a significantly more complex and powerful language syntax.  Adding to that, <em>Despair Engine</em> was intended to be cross-platform, and we didn&#8217;t even have specs on some of the platforms we were promising to support.  Because of this, we considered the possibility of dispensing with dynamic shader linking entirely and adopting a conventional HLSL pipeline, implementing our broad feature set with a mixture of compile-time, static, and dynamic branching.  In the end, however, I had enjoyed so much success with the dynamic shader linking architecture of <em>MechAssault 2</em>, I couldn&#8217;t bear to accept either the performance cost of runtime branching or the clunky limitations of precomputing all possible shader permutations.</p>
<p>The decision was made: <em>Despair Engine</em> would feature <em>CrossStitch 2.0</em>.  I don&#8217;t recall how long it took me to write the first version of <em>CrossStitch 2.0</em>.  The early days of Despair development are a blur because we were supporting the completion of <em>MechAssault 2</em> while bootstrapping an entirely new engine on a constantly shifting development platform and work was always proceeding on all fronts.  I know that by December of 2004, however, <em>Despair Engine</em> had a functional implementation of dynamic shader linking in HLSL.</p>
<p><em>CrossStitch 2.0</em> is similar in design to its predecessor.  It features a front-end compiler that transforms shader fragments into an intermediate binary, and a back-end linker that transforms a chain of fragments into a full shader program.  The difference, of course, is that now the front-end compiler parses HLSL syntax and the back-end linker generates HLSL programs.  Since <em>CrossStitch 1.0</em> was mostly limited to vertex shaders with fixed output registers, <em>CrossStitch 2.0</em> introduced a more flexible model for passing data between pipeline stages.  Variables can define and be mapped to named input and output channels; and each shader chain requires an input signature from the stage preceding it and generates an output signature for the stage following it.</p>
<div id="attachment_463" style="width: 671px" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-463" loading="lazy" class="size-full wp-image-463 " style="border: 1px solid black;" title="HLSL Fragments" src="http://gameangst.com/wp-content/uploads/2010/05/HLSLFragments1.jpg" alt="" width="661" height="710" srcset="http://gameangst.com/wp-content/uploads/2010/05/HLSLFragments1.jpg 661w, http://gameangst.com/wp-content/uploads/2010/05/HLSLFragments1-139x150.jpg 139w, http://gameangst.com/wp-content/uploads/2010/05/HLSLFragments1-372x400.jpg 372w" sizes="(max-width: 661px) 100vw, 661px" /><p id="caption-attachment-463" class="wp-caption-text">A sampling of early HLSL shader fragments.</p></div>
<p><em>CrossStitch&#8217;s</em> primary concern is GPU runtime efficiency, so it is nice that shaders are compiled with full knowledge of the data they&#8217;ll be receiving either from vertex buffers or interpolators.  If, for example, some meshes include per-vertex color and some don&#8217;t, the same series of shader fragments will generate separate programs optimized for each case.  It turns out that this explicit binding of shader programs to attributes and interpolators is a common requirement of graphics hardware, and making the binding explicit in <em>CrossStitch</em> allows for some handy optimizations on fixed consoles.</p>
<p>The early results from <em>CrossStitch 2.0</em> were extremely positive.  The HLSL syntax was a nice break from assembly, and the dynamic fragment system allowed me to quickly and easily experiment with a wide range of options as our rendering pipeline matured.  Just as had happened with <em>MechAssault 2</em>, the feature set of Despair expanded rapidly to become heavily reliant on the capabilities of <em>CrossStitch</em>.  The relationship proved circular too.  Just as <em>CrossStitch</em> facilitated a growth in Despair&#8217;s features, Despair&#8217;s features demanded a growth in <em>CrossStitch&#8217;s</em> capabilities.</p>
<p>The biggest example of this is Despair&#8217;s material editor, <em>Façade</em>.  <em>Façade</em> is a graph-based editor that allows content creators to design extremely complex and flexible materials for every asset.  The materials are presented as a single pipeline flow, taking generic mesh input attributes and transforming them through a series of operations into a common set of material output attributes.  To implement <em>Façade</em>, I both harnessed and extended the power of <em>CrossStitch</em>.  Every core node in a <em>Facade</em> material graph is a shader fragment.  I added reflection support to the <em>CrossStich</em> compiler, so adding a new type of node to <em>Façade</em> is as simple as creating a new shader fragment and annotating its public-facing variables.  Since <em>CrossStitch</em> abstracts away many of the differences between pipeline stages, <em>Façade</em> material graphs don&#8217;t differentiate between per-vertex and per-pixel operations.  The flow of data between pipeline stages is managed automatically depending on the requirements of the graph.</p>
<div id="attachment_458" style="width: 410px" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-458" loading="lazy" class="size-full wp-image-458 " title="facade" src="http://gameangst.com/wp-content/uploads/2010/05/facade.jpg" alt="" width="400" height="332" srcset="http://gameangst.com/wp-content/uploads/2010/05/facade.jpg 400w, http://gameangst.com/wp-content/uploads/2010/05/facade-150x124.jpg 150w" sizes="(max-width: 400px) 100vw, 400px" /><p id="caption-attachment-458" class="wp-caption-text">Façade Material Editor</p></div>
<p>It was about 6 months after the introduction of <em>Façade</em> when the first cracks in <em>CrossStitch</em> began to appear.  The problem was shader compilation times.  On <em>MechAssault 2</em> we measured shader compilation times in microseconds.  Loading a brand new level with no cached shader programs in <em>MechAssault 2</em> might cause a half-second hitch as a hundred new shaders were compiled.  If a few new shaders were encountered during actual play, a couple of extra milliseconds in a frame didn&#8217;t impact the designers&#8217; ability to evaluate their work.  Our initial HLSL shaders were probably a hundred times slower to compile than that on a high-end branch-friendly PC.  By the end of 2005 we had moved to proper Xbox 360 development kits and our artists had mastered designing complex effects in <em>Façade</em>.  Single shaders were now taking as long as several seconds to compile, and virtually every asset represented a half-dozen unique shaders.</p>
<p>The unexpected 4-5 decimal order of magnitude increase in shader compilation times proved disastrous.  <em>CrossStitch</em> was supposed to allow the gameplay programmers, artists, and designers to remain blissfully ignorant of how the graphics feature set was implemented.  Now, all of a sudden, everyone on the team was aware of the cost of shader compilation.  The pause for shader compilation was long enough that it could easily be mistaken for a crash, and, since it was done entirely on the fly, on-screen notification of the event couldn&#8217;t be given until <em>after</em> it was complete.  Attempts to make shader compilation asynchronous weren&#8217;t very successful because at best objects would pop in seconds after they were supposed to be visible and at worst a subset of the passes in a multipass process would be skipped resulting in unpredictable graphical artifacts.  Making matters worse, the long delays at level load were followed by massive hitches as new shaders were encountered during play.  It seemed like no matter how many times a designer played a level, new combinations of lighting and effects would be encountered and repeated second-long frame rate hitches would make evaluating the gameplay impossible.</p>
<p>Something had to be done and fast.</p>
<p>Simple optimization was never an option, because almost the entire cost of compilation was in the HLSL compiler itself.  Instead I focused my efforts on the <em>CrossStitch</em> shader cache.  The local cache was made smarter and more efficient, and extended so that multiple caches could be processed simultaneously.  That allowed the QA staff to start checking in their shader caches, which meant tested assets came bundled with all their requisite shaders.  Of course content creators frequently work with untested assets, so there was still a lot of unnecessary redundant shader compilation going on.</p>
<p>To further improve things we introduced a network shader cache.  Shaders were still compiled on-target, but when a missing shader was encountered it would be fetched from a network server before being compiled locally.  Clients updated servers with newly compiled shaders, and since Day 1 has multiple offices and supports distributed development, multiple servers had to be smart enough to act as proxies for one another.</p>
<p>With improvements to the shader cache, life with dynamic, on-the-fly shader compilation was tolerable but not great.  The caching system has only had a few bugs in its lifetime, but it is far more complicated than you might expect and only really understood by a couple of people.  Consequently, a sort of mythology has developed around the shader cache.  Just as programmers will suggest a full rebuild to one another as a possible solution to an inexplicable code bug, content creators and testers can be heard asking each other, &#8220;have you tried deleting your shader cache?&#8221;</p>
<p>At the same time as I was making improvements to the shader cache, I was also working towards the goal of having all shaders needed for an asset compiled at the time the asset was loaded.  I figured compiling shaders at load time would solve the in-game hitching problem and it also seemed like a necessary step towards my eventual goal of moving shader compilation offline.  Unfortunately, doing that without fundamentally changing the nature and usage of <em>CrossStitch</em> was equivalent to solving the halting problem.  <em>CrossStitch</em> exposes literally billions of possible shader programs to the content, taking advantage of the fact that only a small fraction of those will actually be used.  Which fraction, however, is determined by a mind-bending, platform-specific tangle of artist content, lua script, and C++ code.</p>
<p>I remember feeling pretty pleased with myself at the end of <em>MechAssault 2</em> when I learned that <em>Far Cry</em> required a 430 megabyte shader cache compared to MA2&#8217;s svelte 500 kilobyte cache.  That satisfaction evaporated pretty quickly during the man-weeks I spent tracking down unpredicted shader combinations in <em>Fracture</em>.</p>
<p>Even so, by the time we entered full production on <em>Fracture</em>, shader compilation was about as good as it was ever going to get.  A nightly build process loaded every production level and generated a fresh cache.  The build process updated the network shader cache in addition to updating the shader cache distributed with resources, so the team had a nearly perfect cache to start each day with.</p>
<p>As if the time costs of shader compilation weren&#8217;t enough, <em>CrossStitch</em> suffered from an even worse problem on the Xbox 360.  <em>Fracture&#8217;s</em> terrain system implemented a splatting system that composited multiple <em>Facade</em> materials into a localized über material, and then decomposed the über material into multiple passes according the register, sampler, and instruction limits of the target profile.  The result was some truly insane shader programs.</p>
<div id="attachment_479" style="width: 410px" class="wp-caption aligncenter"><img aria-describedby="caption-attachment-479" loading="lazy" class="size-full wp-image-479 " title="Fracture Terrain Material" src="http://gameangst.com/wp-content/uploads/2010/05/terrain_material.jpg" alt="" width="400" height="400" srcset="http://gameangst.com/wp-content/uploads/2010/05/terrain_material.jpg 400w, http://gameangst.com/wp-content/uploads/2010/05/terrain_material-150x150.jpg 150w" sizes="(max-width: 400px) 100vw, 400px" /><p id="caption-attachment-479" class="wp-caption-text">The procedurally generated material for one pass of a terrain tile in Fracture.</p></div>
<p>A few <em>Fracture</em> terrain shaders took over 30 seconds to compile and consumed over 160 megabytes of memory in the process.  Since the Xbox 360 development kits have no spare memory, this posed a major problem.  There were times when the content creators would generate a shader that could not be compiled on target without running out of memory and crashing.  It has only happened three times in five years, but we&#8217;ve actually had to run the game in a special, minimal memory mode in order to free up enough memory to compile a necessary shader for a particularly complex piece of content.  Once the shader is present in the network cache, the offending content can be checked in and the rest of the team is none the wiser.</p>
<p><a href="http://www.gamasutra.com/view/feature/4111/dirty_coding_tricks.php">Such things are not unusual in game development</a>, but it still kills me to be responsible for such a god-awful hack of a process.</p>
<p>And yet, <em>CrossStitch</em> continues to earn its keep.  Having our own compiler bridging the gap between our shader code and the platform compiler has proved to be a very powerful thing.  When we added support for the Playstation 3, Chris modified the <em>CrossStitch</em> back-end to compensate for little differences in the Cg compiler.  When I began to worry that some of our shaders were interpolator bound on the Xbox 360, the <em>CrossStitch</em> back-end was modified to perform automatic interpolator packing.  When I added support for Direct3D 10 and several texture formats went missing, <em>CrossStitch</em> allowed me to emulate the missing texture formats in late-bound fragments.  There doesn&#8217;t seem to be a problem <em>CrossStitch</em> can&#8217;t solve, except, of course, for the staggering inefficiency of its on-target, on-the-fly compilation.</p>
<p>For our next project I&#8217;m going to remove <em>CrossStitch</em> from Despair.  I&#8217;m going to do it with a scalpel if possible, but I&#8217;ll do it with a chainsaw if necessary.  I&#8217;m nervous about it, because despite my angst and my disillusionment with dynamic shader compilation, Day 1&#8217;s artists are almost universally fans of the Despair renderer.  They see <em>Façade</em> and the other elements of Despair graphics as a powerful and flexible package that lets them flex their artistic muscles.  I can&#8217;t take that away from them, but I also can&#8217;t bear to write another line of code to work around the costs of on-the-fly shader compilation.</p>
<p>It is clear to me now what I didn&#8217;t want to accept five years ago.  Everyone who has a say in it sees the evolution of GPU programs paralleling the evolution of CPU programs: code is static and data is dynamic.  <em>CrossStitch</em> has had a good run, but fighting the prevailing trends is never a happy enterprise.  Frameworks like DirectX Effects and CgFx have become far more full-featured and production-ready than I expected, and I&#8217;m reasonably confident I can find a way to map the majority of Despair&#8217;s graphics features onto them.  Whatever I come up with, it will draw a clear line between the engine and its shaders and ensure that shaders can be compiled wherever and whenever future platforms demand.</p>
							</div>
			
			<p class="entry-meta"><!-- <span class="entry-categories">Posted in: <a href="http://gameangst.com/?cat=1" rel="category">Uncategorized</a>.</span><br /> -->
							<span class="entry-tags">Tagged: <a href="http://gameangst.com/?tag=crossstitch" rel="tag">CrossStitch</a> &middot; <a href="http://gameangst.com/?tag=despair-engine" rel="tag">Despair Engine</a> &middot; <a href="http://gameangst.com/?tag=fracture" rel="tag">Fracture</a> &middot; <a href="http://gameangst.com/?tag=rendering" rel="tag">rendering</a><br /></span>
			</p>
		</div><!--.entry-->
		
				
		<div id="post-402" class="entry post-402 post type-post status-publish format-standard hentry category-uncategorized tag-crossstitch tag-mechassault tag-rendering">
			
			<h2 class="entry-title"><a href="http://gameangst.com/?p=402" rel="bookmark" title="Permalink to CrossStitch: A Configurable Pipeline for Programmable Shading">CrossStitch: A Configurable Pipeline for Programmable Shading</a></h2>
			
			<div class="entry-byline">
				<span class="entry-date"><abbr class="updated" title="2010-05-03T12:38:49-0400">May 3rd, 2010</abbr></span>
				<address class="author vcard">by <a class="url fn" href="http://">Adrian Stone</a>. </address>
				<a href="http://gameangst.com/?p=402#comments" class="comments-link" >6 comments</a>							</div>
			
			<div class="entry-content">
				<p>Some pieces of code are a source of great pride and some pieces of code are a source of terrible shame.  It is due to the nature of game development, I believe, that many of the most interesting pieces of code I write eventually become both.  That is certainly the case with the <em>CrossStitch</em> shader assembler, my first significant undertaking in the field of computer graphics.</p>
<p><em>CrossStitch</em> has been the foundation of Day 1&#8217;s graphics libraries for over seven years now, and for almost half of that time it has been a regular source of frustration and embarrassment for me.  What I&#8217;d like to do is vent my frustration and write an article explaining all the ways in which I went wrong with <em>CrossStitch</em> and why, despite my hatred of it, I continue to put up with it.  But before I can do that I need to write this article, a remembrance of where <em>CrossStitch</em> came from and how I once loved it so much.</p>
<p>My first job in the game industry had me implementing the in-game UI for a flight simulator.  When that project was canceled, I switched to an adventure game, for which I handled tools and 3dsmax exporter work and later gameplay and graphical scripting language design.  A couple years later I found myself in charge of the networking code for an action multiplayer title, and shortly after that I inherited the AI and audio code.  Next I came back to scripting languages for a bit and worked with Lua integration, then I spent six months writing a physics engine before becoming the lead on the Xbox port of a PS2 title.  I only had a few people reporting to me as platform lead, so my responsibilities ended up being core systems, memory management, file systems, optimization, and pipeline tools.</p>
<p>When I interviewed at Day 1, one of the senior engineers asked me what I thought my greatest weakness was as a game developer and I answered honestly that although I&#8217;d worked in almost every area of game development, I&#8217;d had little or no exposure to graphics.  Imagine my surprise when less than a month after he hired me the studio director came to me and asked if I&#8217;d be willing to step into the role of graphics engineer.  It turned out that both of Day 1&#8217;s previous graphics engineers had left shortly before my arrival, and the company was without anyone to fill the role.  I was excited for the challenge and the opportunity to try something new, so I quickly accepted the position and went to work.</p>
<p>This left me in a very strange position, however.  I was inheriting the graphics code from <a href="http://www.xbox.com/en-US/games/m/mechassault/"><em>MechAssault</em></a>, so I had a fully working, shippable code base to cut my teeth on, but I was also inheriting a code base with no owner in a discipline for which I had little training, little experience, and no available mentor.  The title we were developing was <a href="http://xbox.ign.com/objects/655/655496.html"><em>MechAssault 2</em></a>, and given that it was a second generation sequel to an unexpected hit, there was a lot of pressure to overhaul the code and attempt a major step forward in graphics quality.</p>
<p>The <em>MechAssault 1</em> graphics engine was first generation Xbox exclusive, which meant fixed-function hardware vertex T&amp;L and fixed-function fragment shading.  As I began to familiarize myself with the code base and the hardware capabilities, I realized that in order to implement the sort of features that I envisioned for <em>MechAssault 2</em>, I&#8217;d need to convert the engine over to programmable shading.  The Xbox had phenomenal vertex shading capability and extremely limited fragment shading capability, so I wanted to do a lot of work in the vertex shader and have the flexibility to pass data to the fragment shader in whatever clever arrangement would allow me to use just a couple instructions to apply whatever per-pixel transformations were necessary to get attractive results on screen.</p>
<p>The problem was that shaders are monolithic single-purpose programs and the entire feature set and design of the graphics engine were reliant on the dynamic, mix-and-match capabilities of the fixed-function architecture.  This is where my lack of experience in graphics and my lack of familiarity with the engine became a problem, because although I was feeling held back by it, I didn&#8217;t feel comfortable cutting existing features or otherwise compromising the existing code.  I wanted the power of programmable shading, but I needed it in the form of a configurable, fixed-function-like pipeline that would be compatible with the architecture I had inherited.</p>
<p>I pondered this dilemma for a few days and eventually a plan for a new programmable shader pipeline started to emerge.  I asked the studio director if I could experiment with converting the graphics engine from fixed-function to programmable shaders, and he found two weeks in the schedule for me to try.  Our agreement was that in order to claim success at the end of two weeks, I had to have our existing feature set working in programmable shaders and I had to be able to show no decrease in memory or performance.</p>
<p>My plan was to write a compiler and linker for a new type of shader program, called shader fragments.  Instead of an object in the game having to specify its entire shader program in a single step, the code path that led to rendering an object would be able to add any number of shader fragments to a list, called a shader chain, and finally the chain would be linked together into a full shader program in time for the object to draw.</p>
<p>My first task was to define the syntax for shader fragments.  I had very limited time so I started with an easily parsable syntax, XML.  Fragments consisted of any number of named variables, any number of constant parameters, and a single block of shader assembly code.  Named variables were either local or global in scope, and they could specify several options such as default initialization, input source (for reading data from vertex attributes), output name (for passing data to fragment shaders), and read-only or write-only flags.</p>
<p>I wrote a simple C preprocessor, an XML parser, and a compiler to transform my fragments into byte-code.  Compiled fragments were linked directly into the executable along with a header file defining the constant parameter names.  Rendering of every object began with clearing the current shader chain and adding a fragment that defined some common global variables with default values.  For example, <em>diffuse</em> was a global, one-initialized variable available to every shader chain and <em>screen_pos</em> was a global variable mapped to the vertex shader position output.  Once the default variables were defined, a mesh might add a new fragment that defined a global variable, <em>vertex_diffuse,</em> with initialization from a vertex attribute and additional global variables for world-space position and normals.  Depending on the type of mesh, world-space position might be a rigid transformation of the vertex position, a single or multi-bone skinned transformation of the vertex position, or a procedurally generated position from a height field or particle system.</p>
<table border="0" cellpadding="0">
<tbody>
<tr>
<td>
<p><div id="attachment_424" style="width: 455px" class="wp-caption alignnone"><img aria-describedby="caption-attachment-424" loading="lazy" class="size-full wp-image-424 " style="border: 1px solid black;" src="http://gameangst.com/wp-content/uploads/2010/04/FragmentMapDefaults.png" alt="" width="445" height="260" /><p id="caption-attachment-424" class="wp-caption-text">Common variables were defined for all shader chains.</p></div></td>
<td>
<p><div id="attachment_417" style="width: 367px" class="wp-caption alignnone"><img aria-describedby="caption-attachment-417" loading="lazy" class="size-full wp-image-417   " style="border: 1px solid black;" title="FragmentGenerateEyeVector.vfrag" src="http://gameangst.com/wp-content/uploads/2010/04/FragmentGenerateEyeVector.png" alt="" width="357" height="230" srcset="http://gameangst.com/wp-content/uploads/2010/04/FragmentGenerateEyeVector.png 357w, http://gameangst.com/wp-content/uploads/2010/04/FragmentGenerateEyeVector-150x96.png 150w" sizes="(max-width: 357px) 100vw, 357px" /><p id="caption-attachment-417" class="wp-caption-text">A shader fragment for generating the eye vector.</p></div></td>
</tr>
</tbody>
</table>
<p>With world-space position and normals defined, other systems could then add fragments to accumulate per-vertex lighting into the global <em>diffuse</em> variable and to modulate <em>diffuse</em> by <em>material_diffuse</em> or <em>vertex_diffuse</em>.  Systems could also continue to define new variables and outputs, for example per-vertex fog or, in the case of per-pixel lighting, tangent space.  Precedence rules also allowed fragments to remap the inputs or outputs or change the default initialization of variables defined in earlier fragments.</p>
<table border="0" cellpadding="0">
<tbody>
<tr>
<td>
<p><div style="width: 330px" class="wp-caption alignnone"><a href="http://xbox.ign.com/dor/objects/655496/mechassault-2-lone-wolf/images/mechassault-2-lone-wolf-20041102060758085.html" target="_blank"><img loading="lazy" class=" " title="MA2 Height Fog" src="http://xboxmedia.ign.com/xbox/image/article/563/563057/mechassault-2-lone-wolf-20041102060758085.jpg" alt="" width="320" height="240" /></a><p class="wp-caption-text">Custom height fog was implemented in shader fragments.</p></div></td>
<td>
<p><div style="width: 330px" class="wp-caption alignnone"><a href="http://xbox.ign.com/dor/objects/655496/mechassault-2-lone-wolf/images/mechassault-2-lone-wolf-20041203113114593.html" target="_blank"><img loading="lazy" class=" " title="MA2 Particle Effects" src="http://xboxmedia.ign.com/xbox/image/article/570/570670/mechassault-2-lone-wolf-20041203113114593.jpg" alt="" width="320" height="240" /></a><p class="wp-caption-text">Particles were generated in shader fragments.</p></div></td>
</tr>
</tbody>
</table>
<p>The final step in rendering an object was to transform the active shader chain into a shader program.  Shader programs were compiled on the fly whenever a new shader chain was encountered, resulting in a small but noticeable frame rate hitch.  Luckily, the shader programs were cached to disk between runs so the impact of new shader compilations was minimal.  I had promised to add no additional CPU or GPU cost to rendering, so I put a lot of care into the code for adding shader fragments to shader chains and for looking up the corresponding shader programs.</p>
<p>It was a nerve-racking few weeks for me, however, because it wasn&#8217;t until I&#8217;d implemented the entire system and replaced every fixed-function feature supported by the engine with equivalent shader fragments that I was able to do side-by-side performance comparisons.  Amazingly, the CPU costs ended up being nearly indistinguishable.  Setting state through the fixed-function calls or setting shader constants and shader fragments was so close in performance that victory by even a narrow margin couldn&#8217;t be determined.</p>
<p>The results on the GPU were equally interesting.  The vertex shader implementation outperformed the fixed-function equivalent for everything except lighting.  Simple materials with little or no lighting averaged 10 &#8211; 20% faster in vertex shader form.  As the number of lights affecting a material increased, however, the margin dropped until the fixed-function implementation took the lead.  Our most complex lighting arrangement, a material with ambient, directional, and 3 point lights, was 25% slower on the GPU when implemented in a vertex shader.  With the mix of materials in our MechAssault levels, the amortized results ended up being about a 5% drop in vertex throughput.  This wasn&#8217;t a big concern for me, however, because we weren&#8217;t even close to being vertex bound on the Xbox, and there were several changes I wanted to make to the lighting model that weren&#8217;t possible in fixed-function but would shave a few instructions off the light shaders.</p>
<p>The studio director was pleased with the results, so I checked in my code and overnight the game went from purely fixed-function graphics to purely programmable shaders.  The shader fragment system, which I named <em>CrossStitch</em>, opened up the engine to a huge variety of GPU-based effects, and the feature set of the engine grew rapidly to become completely dependent on shader fragments.  By the time we shipped MechAssault 2, our rendering was composed of over 100 unique shader fragments.  These fragments represented billions of possible shader program permutations, though thankfully only a little more than 500 were present in our final content.</p>
<p>Here are some examples of features in MechAssault 2 that were made possible by shader fragments:</p>
<ul>
<li>a new particle effects system which offloaded some of the simulation costs to the GPU</li>
<li>procedural vertex animation for waving flags and twisting foliage</li>
<li>a space-warp effect attached to certain explosions and projectiles that deformed the geometry of nearby objects</li>
<li>mesh bloating and stretching modifiers for overlay shields and motion blur effects</li>
<li>GPU-based shadow volume extrusion</li>
<li>per-vertex and per-pixel lighting with numerous light types and variable numbers of lights</li>
<li>GPU-based procedural UV generation for projected textures, gobo lights, and decals</li>
<li>content-dependent mesh compression with GPU-based decompression</li>
</ul>
<table border="0" cellpadding="0">
<tbody>
<tr>
<td>
<p><div style="width: 330px" class="wp-caption alignnone"><a href="http://xbox.ign.com/dor/objects/655496/mechassault-2-lone-wolf/images/mechassault-2-lone-wolf-20041020020532474.html" target="_blank"><img loading="lazy" class=" " title="MA2 Space Warp" src="http://xboxmedia.ign.com/xbox/image/article/558/558475/mechassault-2-lone-wolf-20041020020532474.jpg" alt="A mech explosion deforms the nearby objects." width="320" height="240" /></a><p class="wp-caption-text">A mech explosion deforms nearby objects.</p></div></td>
<td>
<p><div id="attachment_420" style="width: 330px" class="wp-caption alignnone"><a href="http://gameangst.com/wp-content/uploads/2010/04/MA2_per_pixel.jpg"><img aria-describedby="caption-attachment-420" loading="lazy" class="size-medium wp-image-420    " title="MA2 Per-pixel Lighting" src="http://gameangst.com/wp-content/uploads/2010/04/MA2_per_pixel-400x300.jpg" alt="" width="320" height="240" srcset="http://gameangst.com/wp-content/uploads/2010/04/MA2_per_pixel-400x300.jpg 400w, http://gameangst.com/wp-content/uploads/2010/04/MA2_per_pixel-150x112.jpg 150w, http://gameangst.com/wp-content/uploads/2010/04/MA2_per_pixel-800x600.jpg 800w, http://gameangst.com/wp-content/uploads/2010/04/MA2_per_pixel.jpg 1024w" sizes="(max-width: 320px) 100vw, 320px" /></a><p id="caption-attachment-420" class="wp-caption-text">MA2 mixed per-vertex and per-pixel lighting.</p></div></td>
</tr>
</tbody>
</table>
<p>By the end of <em>MechAssault 2</em> I was convinced <em>CrossStitch</em> was the only way to program graphics.  I absolutely loved the dynamic shader assembly model I&#8217;d implemented, and I never had a second&#8217;s regret over it.  It was fast, memory efficient, and allowed me to think about graphics in the way I found most natural, as a powerful configurable pipeline of discrete transformations.  If only the story could end there.</p>
<p>In the future I&#8217;ll have to write a follow up to this article describing how <em>CrossStitch</em> evolved after <em>MechAssault 2</em>.  I&#8217;ll have to explain how it grew in sophistication and capability to keep pace with the advances in 3-D hardware, to support high-level language syntax and to abstract away the increasing number of programmable hardware stages.  I&#8217;ll have to explain why the path it followed seemed like such a good one, offering the seduction of fabulous visuals at minimal runtime cost.  But most importantly, I&#8217;ll have to explain how far along that path I was before I realized it was headed in a direction I didn&#8217;t want to be going, a direction completely divergent with the rest of the industry.</p>
							</div>
			
			<p class="entry-meta"><!-- <span class="entry-categories">Posted in: <a href="http://gameangst.com/?cat=1" rel="category">Uncategorized</a>.</span><br /> -->
							<span class="entry-tags">Tagged: <a href="http://gameangst.com/?tag=crossstitch" rel="tag">CrossStitch</a> &middot; <a href="http://gameangst.com/?tag=mechassault" rel="tag">MechAssault</a> &middot; <a href="http://gameangst.com/?tag=rendering" rel="tag">rendering</a><br /></span>
			</p>
		</div><!--.entry-->
		
				
		
	<div class="navigation">
		<div class="navleft"><a href="http://gameangst.com/favicon.ico/?paged=2" >&#8592; Earlier Posts</a></div>
		<div class="navright"></div>
		<div class="clear"></div>
	</div>

		
			

	</div><!--#primary-->
	
<div id="secondary">

<div id="pp-subscribe" class="clearfix">
	<ul class="clearfix">
	<li id="pp-feed">
		<a href="http://gameangst.com/?feed=rss2">Subscribe via RSS</a>
	</li>

		</ul>
</div>
<div id="pp-sidebars" class="clearfix">

<div id="sidebar-wide" class="sidebar">
	
	<ul class="xoxo sidebar-items">
	<li id="search-2" class="widget widget_search"><h2 class="widgettitle search-title">Search</h2>
<form method="get" id="pp-searchform" action="http://gameangst.com">
<div>
	<input type="text" name="s" id="s-input" maxlength="150" accesskey="4" title="Search Game Angst" onblur="this.value=(this.value=='') ? 'Type and hit enter to search' : this.value;" onfocus="this.value=(this.value=='Type and hit enter to search') ? '' : this.value;" value="Type and hit enter to search" />
	<input type="hidden" id="s-submit" value="Search" />
</div>
</form></li>
		<li id="recent-posts-2" class="widget widget_recent_entries">
		<h2 class="widgettitle">Recent Posts</h2>
		<ul>
											<li>
					<a href="http://gameangst.com/?p=585">Low-Fragmentation, High-Performance Memory Allocation in Despair Engine</a>
									</li>
											<li>
					<a href="http://gameangst.com/?p=526">Scalable Concurrency in Despair Engine</a>
									</li>
											<li>
					<a href="http://gameangst.com/?p=496">The Hole That dlmalloc Can&#8217;t Fill</a>
									</li>
											<li>
					<a href="http://gameangst.com/?p=441">CrossStitch 2.0: Dynamic Shader Linking in a Statically Linked World</a>
									</li>
											<li>
					<a href="http://gameangst.com/?p=402">CrossStitch: A Configurable Pipeline for Programmable Shading</a>
									</li>
					</ul>

		</li><li id="tag_cloud-2" class="widget widget_tag_cloud"><h2 class="widgettitle">Tags</h2><div class="tagcloud"><a href="http://gameangst.com/?tag=angst" class="tag-cloud-link tag-link-10 tag-link-position-1" style="font-size: 8pt;" aria-label="angst (1 item)">angst</a>
<a href="http://gameangst.com/?tag=c" class="tag-cloud-link tag-link-8 tag-link-position-2" style="font-size: 20.5641025641pt;" aria-label="C++ (9 items)">C++</a>
<a href="http://gameangst.com/?tag=code-bloat" class="tag-cloud-link tag-link-14 tag-link-position-3" style="font-size: 18.7692307692pt;" aria-label="code bloat (7 items)">code bloat</a>
<a href="http://gameangst.com/?tag=concurrency" class="tag-cloud-link tag-link-19 tag-link-position-4" style="font-size: 8pt;" aria-label="concurrency (1 item)">concurrency</a>
<a href="http://gameangst.com/?tag=crossstitch" class="tag-cloud-link tag-link-17 tag-link-position-5" style="font-size: 11.2307692308pt;" aria-label="CrossStitch (2 items)">CrossStitch</a>
<a href="http://gameangst.com/?tag=deferred-shading" class="tag-cloud-link tag-link-12 tag-link-position-6" style="font-size: 11.2307692308pt;" aria-label="deferred shading (2 items)">deferred shading</a>
<a href="http://gameangst.com/?tag=despair-engine" class="tag-cloud-link tag-link-11 tag-link-position-7" style="font-size: 18.7692307692pt;" aria-label="Despair Engine (7 items)">Despair Engine</a>
<a href="http://gameangst.com/?tag=f-e-a-r-3" class="tag-cloud-link tag-link-18 tag-link-position-8" style="font-size: 8pt;" aria-label="F.E.A.R. 3 (1 item)">F.E.A.R. 3</a>
<a href="http://gameangst.com/?tag=fracture" class="tag-cloud-link tag-link-15 tag-link-position-9" style="font-size: 13.3846153846pt;" aria-label="Fracture (3 items)">Fracture</a>
<a href="http://gameangst.com/?tag=gdc" class="tag-cloud-link tag-link-9 tag-link-position-10" style="font-size: 8pt;" aria-label="GDC (1 item)">GDC</a>
<a href="http://gameangst.com/?tag=hello-world" class="tag-cloud-link tag-link-4 tag-link-position-11" style="font-size: 8pt;" aria-label="hello world (1 item)">hello world</a>
<a href="http://gameangst.com/?tag=mechassault" class="tag-cloud-link tag-link-16 tag-link-position-12" style="font-size: 8pt;" aria-label="MechAssault (1 item)">MechAssault</a>
<a href="http://gameangst.com/?tag=optimization" class="tag-cloud-link tag-link-7 tag-link-position-13" style="font-size: 22pt;" aria-label="optimization (11 items)">optimization</a>
<a href="http://gameangst.com/?tag=rendering" class="tag-cloud-link tag-link-6 tag-link-position-14" style="font-size: 18.7692307692pt;" aria-label="rendering (7 items)">rendering</a>
<a href="http://gameangst.com/?tag=siggraph" class="tag-cloud-link tag-link-13 tag-link-position-15" style="font-size: 8pt;" aria-label="SIGGRAPH (1 item)">SIGGRAPH</a></div>
</li><li id="archives-2" class="widget widget_archive"><h2 class="widgettitle">Archives</h2>
			<ul>
					<li><a href='http://gameangst.com/?m=201205'>May 2012</a></li>
	<li><a href='http://gameangst.com/?m=201204'>April 2012</a></li>
	<li><a href='http://gameangst.com/?m=201203'>March 2012</a></li>
	<li><a href='http://gameangst.com/?m=201005'>May 2010</a></li>
	<li><a href='http://gameangst.com/?m=201001'>January 2010</a></li>
	<li><a href='http://gameangst.com/?m=200909'>September 2009</a></li>
	<li><a href='http://gameangst.com/?m=200908'>August 2009</a></li>
	<li><a href='http://gameangst.com/?m=200906'>June 2009</a></li>
	<li><a href='http://gameangst.com/?m=200905'>May 2009</a></li>
	<li><a href='http://gameangst.com/?m=200904'>April 2009</a></li>
	<li><a href='http://gameangst.com/?m=200903'>March 2009</a></li>
			</ul>

			</li><li id="linkcat-2" class="widget widget_links"><h2 class="widgettitle">Blogroll</h2>
	<ul class='xoxo blogroll'>
<li><a href="http://beautifulpixels.blogspot.com/" title="Vincent Scheib&#8217;s blog">Beautiful Pixels</a></li>
<li><a href="http://www.brettdouville.com/" title="Brett Douville&#8217;s blog">Brett&#8217;s Footnotes</a></li>
<li><a href="http://www.chrishecker.com/Homepage">Chris Hecker&#8217;s Homepage</a></li>
<li><a href="http://diaryofagraphicsprogrammer.blogspot.com/" title="Wolfgang Engel&#8217;s Blog" target="_blank">Diary of a Graphics Programmer</a></li>
<li><a href="http://www.gamearchitect.net" title="Kyle Wilson&#8217;s musings on game engine design">GameArchitect</a></li>
<li><a href="http://www.humus.name/" title="Emil Persson&#8217;s Blog">Humus</a></li>
<li><a href="http://www.realtimerendering.com/blog/" title="The official blog of the book!">Real-Time Rendering</a></li>
<li><a href="http://realtimecollisiondetection.net/blog/" title="Christer Ericson&#8217;s blog">realtimecollisiondetection.net</a></li>
<li><a href="http://herbsutter.wordpress.com/" title="Herb Sutter on software, hardware, and concurrency">Sutter&#8217;s Mill</a></li>

	</ul>
</li>
<li id="meta-2" class="widget widget_meta"><h2 class="widgettitle">Meta</h2>
		<ul>
						<li><a href="http://gameangst.com/wp-login.php">Log in</a></li>
			<li><a href="http://gameangst.com/?feed=rss2">Entries feed</a></li>
			<li><a href="http://gameangst.com/?feed=comments-rss2">Comments feed</a></li>

			<li><a href="https://wordpress.org/">WordPress.org</a></li>
		</ul>

		</li><!--#sidebar-wide widgets end-->
	</ul>

</div><!--#sidebar-wide-->
</div><!--#pp-sidebars-->

</div><!--#secondary-->
	<div id="footer">
		<p class="left">&#169; 2022 <strong>Game Angst</strong> | Powered by <strong><a href="http://wordpress.org/">WordPress</a></strong></p>
		<p class="right">Based on a <strong><a href="http://www.techtrot.com/primepress/" title="PrimePress theme homepage">WordPress theme</a></strong> by <strong><a href="http://www.techtrot.com" title="PrimePress author homepage">Ravi Varma</a></strong></p>
	</div><!--#footer-->

</div><!--#container-->	
	
<div class="clear"></div>	
</div><!--#page-->
<script type='text/javascript' src='http://gameangst.com/wp-includes/js/wp-embed.min.js?ver=5.8.4' id='wp-embed-js'></script>
</body>
</html>